## ✅ 一、【最高频】深度搜索/广度搜索 + 算法核心（你刚考深度搜索，这部分100%再考，重中之重）
### ▶ 1. 深度优先搜索 DFS + 广度优先搜索 BFS 【必考大题/简答，中英对照+核心考点，已考DFS，必考点BFS+二者对比】
#### 核心概念（中英对照，默写级）
- 深度优先搜索：**DFS (Depth-First Search)** —— 「先走到底，再回头」，沿着一条路径递归遍历到最深节点，无路可走时**回溯**，再遍历下一条分支。
- 广度优先搜索：**BFS (Breadth-First Search)** —— 「层层递进，先广后深」，按**层级/距离**遍历，先访问当前节点的所有邻接节点，再依次访问邻接节点的子节点，用队列实现。
- 共同作用：图(Graph)、树(Tree)的遍历核心算法，也用于组合/排列/路径类问题求解。

#### 核心实现与特性（必考结论，背熟）
1. DFS：实现方式 → **递归(Recursion)** 为主，也可用栈(Stack)模拟；空间复杂度低，时间复杂度和BFS一致；特点：容易实现，适合找「一条可行路径」「所有路径」「是否存在路径」。
   - 典型应用：树的前/中/后序遍历、图的连通性检测、全排列/子集问题、回溯算法、迷宫寻路。
2. BFS：实现方式 → **队列(Queue)** 唯一实现；特点：能找到「最短路径」（无权图），适合找最优解；缺点：空间复杂度略高（需要存储每一层节点）。
   - 典型应用：树的层序遍历、无权图最短路径、二叉树最小深度、朋友圈问题。

#### 必考简答：DFS 与 BFS 的核心区别（默写）
① 遍历顺序：DFS是**深度优先，纵向遍历**；BFS是**广度优先，横向遍历**；
② 实现结构：DFS用「递归/栈」，BFS用「队列」；
③ 应用场景：DFS求「所有解/任意解」，BFS求「最短解/最优解」；
④ 空间占用：DFS空间≈递归深度/栈深度，BFS空间≈每层节点数最大值。

#### 延伸必考：回溯算法 (Backtracking)
- 本质：**带剪枝的DFS**，属于DFS的优化版；核心逻辑：「尝试-失败-回退-再尝试」。
- 核心考点：回溯是DFS的子集，DFS是回溯的基础，回溯多了「剪枝(Pruning)」步骤，减少无效遍历，时间复杂度更低。
- 典型例题：组合求和、八皇后问题、子集去重。

### ▶ 2. 时间复杂度 + 空间复杂度 【你已考，必考延伸+计算+排序，填空/选择100%考】
#### 核心概念（中英对照，精准定义）
- 时间复杂度 (Time Complexity)：衡量算法执行所需的**时间量级**，只看「最高阶项」，忽略常数项/低阶项，记为 $O(·)$ ；反映**数据规模n增大时，时间增长的趋势**。
- 空间复杂度 (Space Complexity)：衡量算法执行所需的**内存空间量级**，同样记为 $O(·)$ ；包含「程序本身空间+变量空间+栈空间(递归)」。
- 注意：复杂度都是「最坏情况(Worst Case)」下的评估，这是考试标准答案。

#### 必考①：复杂度优先级排序（从小到大，默写，选择题必出）
 $$ O(1) < O(\log_2n) < O(n) < O(n\log_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) $$ 
 
✅ 备注: $\log_2n$ 简写为 $\log n$ ，考试两种写法都算对。

#### 必考②：所有高频算法/结构的复杂度（全部记熟，已考DFS，全部是高频考点）
1. 基础遍历/查找
   - 顺序查找、数组遍历、链表遍历 → $O(n)$
   - 二分查找（有序数组）→ $O(\log n)$ 【极高概率考】
   - 哈希表(HashMap/HashSet) 增删改查 → $O(1)$（无冲突）/ $O(n)$（最坏冲突）

2. 排序算法（重中之重，必考+默写，选择/填空）
   - 冒泡/选择/插入排序 → 时间 $O(n^2)$ ，空间 $O(1)$ 
   - 快速排序/归并排序/堆排序 → 时间 $O(n\log n)$ 【考试核心】
   - 考点：快速排序是「实际应用最快」，归并排序是「稳定的 $n\log n$ 排序」

3. 搜索算法（你已考，必考延伸）
   - DFS/ BFS 遍历树/图 → 时间 $O(n)$（n为节点数），空间 $O(n)$
   - 回溯算法 → 时间 $O(2^n)$（组合/排列类），空间 $O(n)$（递归栈）

4. 树相关操作
   - 二叉搜索树(BST)的增删查 → 平均 $O(\log n)$，最坏 $O(n)$（退化成链表）
   - 平衡二叉树(AVL/红黑树) → 增删查都是 $O(\log n)$

#### 必考③：复杂度计算技巧（易错点，计算题必出）
- 单层循环 → $O(n)$，双层嵌套循环 → $O(n^2)$，三层 → $O(n^3)$；
- 循环中每次除以2 → $O(\log n)$（如二分查找）；
- 递归调用自身1次 → $O(n)$（如DFS遍历），递归调用自身2次 → $O(2^n)$（如斐波那契递归）；
- 空间复杂度：递归的空间复杂度 = 递归深度，非递归的空间复杂度看开辟的数组/队列大小。

#### 易错点
1. 把 $O(\log n)$ 和 $O(n)$ 搞反，比如二分查找写成 $O(n)$；
2. 递归算法只算时间，忽略空间复杂度（递归的栈空间必须算）；
3. 快速排序的平均复杂度是 $O(n\log n)$，最坏是 $O(n^2)$，考试问「最优/平均」写前者，问「最坏」写后者。

---

## ✅ 二、【最高频】内存管理 + 内存释放 + 内存泄漏 【你刚考内存释放，这部分100%再考，简答/选择必考】
### ▶ 核心概念（中英对照，精准定义，默写级，全部是考点）
1. 内存分配 (Memory Allocation)：程序运行时，系统为变量/对象/数组分配内存空间的过程，内存分为两大块，**考试只考这两个，无其他**：
   - 栈内存 (Stack Memory)：**系统自动分配 + 系统自动释放**，存储「局部变量、函数参数、临时变量」；栈空间小、速度快，遵循「后进先出LIFO」。
   - 堆内存 (Heap Memory)：**程序员手动申请 + 程序员手动释放（部分语言自动）**，存储「对象、数组、动态分配的数据」；堆空间大、速度慢，无固定顺序。
   ✅ 必考结论：**栈内存不用程序员管，堆内存必须手动释放，否则必出问题！**

2. 内存释放 (Memory Release)：归还已分配的内存空间给系统，避免内存浪费。
   - 核心考点：**内存释放的核心对象是「堆内存」，栈内存不需要释放**。
   - 语言差异（必考选择）：
     ✔ C/C++：手动申请 `malloc/new` → 必须手动释放 `free/delete`，否则内存泄漏；
     ✔ Java/Python：自动申请内存 → 垃圾回收机制(GC)自动释放堆内存，无需手动操作；
     ✔ 易错点：Java中即使有GC，也可能出现内存泄漏，不是绝对安全。

3. 内存泄漏 (Memory Leak) 【必考简答，极高概率】
   - 定义：**堆内存被申请后，不再使用，但始终没有被释放**，导致这部分内存被永久占用，系统可用内存越来越少，最终程序崩溃。
   - 原因：忘记释放堆内存、指针丢失（指向堆内存的指针被覆盖，找不到内存地址）、对象被长期引用（Java）。
   - 后果：内存泄漏是「慢性问题」，不会立刻崩溃，但会导致程序运行越久越卡顿，最终OutOfMemory。

4. 内存溢出 (Memory Overflow) 【必考，和内存泄漏成对出现】
   - 定义：**程序申请的内存空间，超过了系统能分配的最大内存**，直接触发报错，程序立刻崩溃。
   - 区别记忆（简答必考）：内存泄漏 → 「占着不用」，内存溢出 → 「不够用」；内存泄漏会**导致**内存溢出，是因果关系。

5. 野指针 (Wild Pointer) 【C/C++必考选择】
   - 定义：指向「已释放的堆内存」或「无效内存地址」的指针，野指针的操作会导致程序崩溃/内存污染，是C/C++的高频错误。

### ▶ 补充必考内存相关概念
1. 内存碎片 (Memory Fragmentation)：堆内存多次分配和释放后，出现的「小块空闲内存」，这些内存总和足够，但无法分配连续的大块内存，导致内存利用率降低。
2. 内存回收机制 (Garbage Collection, GC)：Java/Python的核心，自动扫描堆内存中的「无用对象」（无引用的对象），并释放其内存，无需程序员手动操作。

### ▶ 必考简答：如何避免内存泄漏？
1. 手动申请的堆内存，使用完毕后必须及时释放（C/C++）；
2. 指针使用完毕后，赋值为NULL，避免成为野指针；
3. Java中及时释放对象的引用（如obj=null），让GC能回收；
4. 避免创建大量无用的对象，减少堆内存的占用。

---

## ✅ 三、【高频】数据结构核心考点（和DFS/时间复杂度强绑定，必考）
### 说明：数据结构的考点全部和你已考的「深度搜索、时间复杂度」联动，是考试的核心载体，所有考点均为高频，无冗余
### ▶ 1. 树 (Tree) 核心考点（100%考，DFS/BFS的核心应用场景）
#### 中英对照+核心概念
- 二叉树 (Binary Tree)：每个节点最多2个子节点，分左子树、右子树；
- 二叉搜索树 (BST)：左子树所有节点值 < 根节点，右子树所有节点值 > 根节点；
- 完全二叉树 (Complete Binary Tree)：除最后一层外，每层都满，最后一层节点靠左排列；
- 堆 (Heap)：完全二叉树，分大顶堆(Max Heap)、小顶堆(Min Heap)。

#### 必考：树的遍历（全部是DFS/BFS的应用，你已考DFS，必考点）
1. 深度优先遍历（DFS）→ 3种，全部递归实现，时间 $O(n)$：
   - 前序遍历：根 → 左 → 右 （必考）
   - 中序遍历：左 → 根 → 右 （BST的中序遍历是有序的，极高概率考）
   - 后序遍历：左 → 右 → 根
2. 广度优先遍历（BFS）→ 层序遍历，队列实现，时间 $O(n)$（必考）

### ▶ 2. 图 (Graph) 核心考点（和DFS/BFS绑定，选择/填空必考）
- 无向图(Undirected Graph) / 有向图(Directed Graph)
- 邻接矩阵(Adjacency Matrix) / 邻接表(Adjacency List)：邻接表空间效率更高，是主流存储方式
- 核心：图的遍历只有两种 → DFS和BFS，和树的遍历逻辑一致，时间复杂度都是$O(n)$（n为顶点数）

### ▶ 3. 栈 & 队列 核心考点（DFS/BFS的实现载体，必考）
- 栈(Stack)：后进先出(LIFO)，核心操作：push(入栈)、pop(出栈)、peek(取栈顶) → 实现DFS
- 队列(Queue)：先进先出(FIFO)，核心操作：enqueue(入队)、dequeue(出队) → 实现BFS
- 必考结论：DFS用栈，BFS用队列，这是二者的本质区别。

### ▶ 4. 哈希表 (Hash Table) 核心考点（选择必考）
- 核心：通过哈希函数将「键(Key)」映射到「值(Value)」，查询效率$O(1)$；
- 必考问题：哈希冲突(Hash Collision) → 解决方式：链地址法(拉链法)、开放寻址法；
- 应用：去重、计数、快速查找，是算法题的高频优化工具。

---

## ✅ 四、【高频】面向对象(OOP)补充必考考点（你已考四大特质，接下来考这些，100%）
### 说明：你已考OOP四大特质（封装/继承/多态/抽象），以下是同套试卷**必然延伸的OOP考点**，全部是选择/填空/简答高频，无遗漏
1. **方法重载(Overload) vs 方法重写(Override)** 【必考简答，默写级】
   - 重载：同一类中，方法名相同，**参数列表不同(个数/类型/顺序)**，返回值无要求 → 编译时多态；
   - 重写：子类中，方法名、参数列表、返回值**完全相同**，重写父类方法体 → 运行时多态；
   - 核心区别：重载是「同一类」，重写是「父子类」。

2. **抽象类(Abstract Class) vs 接口(Interface)** 【极高概率考简答】
   - 抽象类：可以有「抽象方法(无方法体)」+「普通方法(有方法体)」，可以有成员变量，**只能单继承**；
   - 接口：只能有「抽象方法(Java8前)」/「默认方法(Java8后)」，只有常量，**可以多实现**；
   - 核心区别：抽象类是「is-a」关系，接口是「has-a」关系；抽象类侧重复用，接口侧重规范。

3. **值传递(Pass by Value) vs 引用传递(Pass by Reference)** 【必考选择】
   - 值传递：传递的是「变量的副本」，修改副本不会改变原变量 → 基本数据类型(int/char/boolean)；
   - 引用传递：传递的是「对象的地址」，修改引用指向的对象，会改变原对象 → 数组/对象/类实例；
   - 必考结论：Java中只有「值传递」，对象的引用也是按值传递。

4. **静态属性/静态方法 (static)** 【必考选择】
   - 静态成员属于「类」，不属于对象，所有对象共享一份；
   - 静态方法中**不能调用非静态成员**，非静态方法可以调用静态成员；
   - 调用方式：类名.静态成员，无需创建对象。

5. **单例模式(Singleton Pattern)** 【必考概念】
   - 定义：一个类只能创建「一个实例对象」，避免多次创建对象浪费内存；
   - 核心：构造方法私有化，提供静态方法返回唯一实例；是最基础的设计模式，考试只考概念。

---

## ✅ 五、【高频】高数-导数+积分 补充必考考点（你已考xcosx+sinx二阶导，接下来考这些，计算题100%）
### 说明：你已考「乘积法则的二阶导」「基本积分公式」，以下是**同套试卷必然考的高数计算题/公式题**，全部是高频，无冗余，公式直接背诵即可
### ▶ 1. 导数补充必考（二阶导为主，全部是你考题的同类型）
#### 已考真题回顾: $f(x) = x\cos x + \sin x$ → $f''(x) = -3\sin x -x\cos x$
#### 必考同类型二阶导题型（全部会算即可，考试换汤不换药）
① $f(x) = x\sin x + \cos x$ → $f'(x) = \sin x +x\cos x - \sin x =x\cos x$ → $f''(x) = \cos x -x\sin x$
② $f(x) = e^x \cos x$ → $f'(x) = e^x\cos x -e^x\sin x$ → $f''(x) = -2e^x\sin x$
③ $f(x) = x^2 \ln x$ → $f'(x) = 2x\ln x +x$ → $f''(x) = 2\ln x +3$

#### 补充必考求导法则（你已考乘积法则，再考这2个）
- 链式法则：$y=f(g(x))$ → $y' = f'(g(x)) \cdot g'(x)$ 如：$(\sin 2x)' = 2\cos2x$
- 商法则：$(\frac{u}{v})' = \frac{u'v - uv'}{v^2}$ 如：$(\frac{\sin x}{x})' = \frac{x\cos x - \sin x}{x^2}$

### ▶ 2. 积分补充必考（全部是你已考的「分部积分」为主，计算题必考）
#### 核心公式：分部积分法 $\int u \, dv = uv - \int v \, du$ （优先级：反对幂三指）
#### 必考积分题型（全部是真题同类型，直接记结果+步骤）
① $\int x\sin x dx = -x\cos x + \sin x + C$ （和你考的xcosx积分互为相反数，必考）
② $\int x e^x dx = e^x(x-1) + C$ （套题已考，再考概率极高）
③ $\int \ln x dx = x\ln x -x + C$ （对数函数积分，必考）
④ 定积分计算：$\int_0^\pi \sin x dx = -\cos x \big|_0^\pi = 2$ （牛顿莱布尼茨公式，必考）

#### 必考积分性质
- 奇偶性：奇函数在对称区间 $[-a,a]$ 的积分=0；偶函数在对称区间 $[-a,a]$ 的积分=2 $\int_0^a f(x)dx$ → 选择必考。

---

## ✅ 六、【中频】程序设计通用核心概念（选择/填空必考，无难度，纯记忆）
### 全部是你考试中「零散考点」，大概率考到，全部中英对照+核心结论，直接背诵
1. **递归(Recursion) vs 迭代(Iteration)**
   - 递归：函数调用自身，有终止条件，代码简洁 → 空间复杂度高（栈），时间复杂度略高；
   - 迭代：用循环实现，代码繁琐 → 空间复杂度低，时间效率高；
   - 结论：递归能实现的，迭代都能实现，迭代效率更高。

2. **编译(Compile) vs 解释(Interpret)**
   - 编译：一次性将源代码翻译成机器码，生成可执行文件 → C/C++，编译器(Compiler)；
   - 解释：逐行翻译源代码，边解释边执行 → Python/Java，解释器(Interpreter)；
   - 必考：Java是「编译+解释」，先编译成字节码，再由JVM解释执行。

3. **异常(Exception) vs 错误(Error)**
   - 异常：程序运行时的「可预见错误」，可以捕获并处理 → 如空指针异常、数组越界异常；
   - 错误：程序运行时的「不可预见错误」，无法处理，直接崩溃 → 如内存溢出错误、栈溢出错误。

4. **常量(Constant) vs 变量(Variable)**
   - 常量：值不可修改，定义后固定 → final关键字(Java)、const关键字(C/C++)；
   - 变量：值可以修改，分为局部变量和成员变量。

---

## ✅ 七、【中频】操作系统+计算机网络 核心考点（选择/填空必考，纯记忆，无难度）
### 说明：这两部分是计算机基础笔试的「送分题」，全部是**高频概念题**，无复杂公式，记结论即可，大概率考到
### ▶ 操作系统(OS)核心考点（全部是选择/填空）
1. 进程(Process) vs 线程(Thread) 【必考】
   - 进程：系统分配资源的**基本单位**，独立内存空间，切换开销大；
   - 线程：CPU调度的**基本单位**，共享进程资源，切换开销小；
   - 结论：一个进程可以有多个线程，线程是进程的子集。

2. 死锁(Deadlock)四大必要条件 【默写级】
   - 互斥条件、请求与保持条件、不剥夺条件、循环等待条件 → 四个条件同时满足，才会发生死锁。

3. 并发(Concurrency) vs 并行(Parallelism)
   - 并发：同一时间段内，多个任务交替执行；
   - 并行：同一时刻，多个任务同时执行；
   - 结论：单核CPU只能并发，多核CPU可以并行。

### ▶ 计算机网络核心考点（全部是选择/填空）
1. TCP vs UDP 【必考】
   - TCP：面向连接、可靠、字节流，三次握手建立连接，四次挥手释放连接 → 适用于文件传输、网页访问；
   - UDP：无连接、不可靠、报文段，速度快 → 适用于视频、音频、直播。

2. HTTP vs HTTPS
   - HTTP：明文传输，端口80，不安全；
   - HTTPS：基于SSL/TLS加密，端口443，安全；
   - 必考结论：HTTPS是HTTP的安全版本，不是新协议。

3. OSI七层模型（从上到下）：应用层→表示层→会话层→传输层→网络层→数据链路层→物理层。

---

## ✅ 考前最后总结：所有考点优先级排序（帮你抓重点，节省时间）
### 🔥 优先级1（100%考，必须全会，分值最高）
1. DFS/BFS的概念+区别+应用；
2. 时间/空间复杂度的排序+计算+高频算法复杂度；
3. 内存释放+内存泄漏+内存溢出+栈/堆内存；
4. 导数二阶导计算题（同类型）+ 分部积分计算题；
5. OOP的重载/重写+抽象类vs接口。

### 🔥 优先级2（80%考，记结论即可）
1. 树的遍历（DFS前中后序+BFS层序）；
2. 哈希表的哈希冲突+解决方式；
3. 进程/线程的区别；
4. TCP/UDP的区别。

### 🔥 优先级3（60%考，纯记忆，送分）
1. 递归vs迭代；
2. 编译vs解释；
3. 死锁的四大条件；
4. OSI七层模型。

以上所有内容，完全覆盖了你已考的所有考点，同时精准命中接下来大概率考到的全部内容，无任何冗余，全部是考试高频考点，直接背诵复习即可！祝你考试顺利！🎉
